<!DOCTYPE html>
<html>
<head>
  <title></title>
  <link href="resources/styles/main.css" rel="stylesheet" type="text/css">
</head>
<body>

<section id="main">
  <pre>
  <div id="aquarium"></div>
  </pre>
</section>

<script src="resources/scripts/extlibs/ramda.js"></script>
<script>

/**
 * * = starfish
       Moves 1/2 turns.
       Only octopi eat starfish.
       A new starfish is spawned every 20 turns;
 * ^ = shark
       Moves 2 spaces.  If anything edible is within those spaces, it is eaten.
       A shark moves 1 space, for 3 turns after it has eaten.
       Can eat other sharks.  Randomize result; plus goes to initiator.
       No new sharks are spawned.
 * # = octopus
 * $ = giant squid
       Can eat sharks.  Can be eaten by sharks.  Randomize result, with a plus
          going to the initiator.
 * @ = jelly fish
       3 jelly fish adjacent to anything kills that thing, other than another jelly fish.
       A new jelly fish is spawned for every thing killed.
       Moves 1/3 turns.
 * > = fish
       Moves 2 spaces.  Moves 3 spaces if a shark is within 3 spaces.
       Eats jelly fish.
       A new fish is spawned for every jelly fish eaten.
 */
/**
 * Top down view
 * Break out items properly
 *   - Actor
 *     - on cell.enter  on cell.exit
 *     - link to the previous sprite
 *     - ActorLogic
 *       -
 *   - Sprite
 *
 * Points have x, y, z values
 * As actors descend in depth, they become darker
 *
 * Implement SSEQ?
 */

function forEachIn(o, fn) {
  var p;
  for (p in o) {
    if (Object.prototype.hasOwnProperty.call(o, p)) {
      fn(p, o[p]);
    }
  }
}

var a = ['alpha', 'beta', 'gamma'];
var b = {};
R.forEach.idx(function(val, ind, lst) {
  b[ind] = val.toUpperCase();
}, a);

function bind(func, obj) {
  return function() {
    return func.apply(obj, arguments);
  };
}

function Dictionary(terms) {
  this.values = terms;
}
Dictionary.prototype.get = function(key) {
  return this.values[key];
};
Dictionary.prototype.set = function(key, val) {
  this.values[key] = val;
  return this.values;
};
Dictionary.prototype.contains = function(key) {
  return Object.prototype.propertyIsEnumerable.call(this.values, key);
};
Dictionary.prototype.each = function(action) {
  forEachIn(this.values, action);
}

function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.add = function(pt) {
  return new Point(this.x + pt.x, this.y + pt.y);
};

function Grid(w, h) {
  this.width = w;
  this.height = h;
  this.cells = new Array(w * h);
}
Grid.prototype.val = function(pt) {
  return this.cells[pt.y * this.width + pt.x];
};
Grid.prototype.set = function(pt, val) {
  this.cells[pt.y * this.width + pt.x] = val;
};
Grid.prototype.isInside = function(pt) {
  return pt.x >= 0 && pt.y >= 0 && pt.x < this.width && pt.y < this.height;
};
Grid.prototype.move = function(from, to) {
  this.set(to, this.val(from));
  this.set(from, null);
};
Grid.prototype.each = function(action) {
  var x, y;
  for (y=0; y < this.height; y++) {
    for (x=0; x < this.width; x++) {
      var pt = new Point(x, y);
      action(pt, this.val(pt));
    }
  }
};

function Top() {
  this.glyph = 'V';
}
Top.prototype.render = function() {
  return '<span style="color:lightseagreen">' + this.glyph + '</span>'
};
function Side() {
  this.glyph = '|';
}
Side.prototype.render = function() {
  return '<span style="color:darkseagreen">' + this.glyph + '</span>'
};
function Bottom() {
  this.glyph = '=';
}
Bottom.prototype.render = function() {
  return '<span style="color:darkseagreen">' + this.glyph + '</span>'
};

function Fish() {
  this.glyph = '>';
}
Fish.prototype.act = function() {
  return {type:"move", direction:"s"};
};
Fish.prototype.render = function() {
  return '<span style="color:lightsalmon">' + this.glyph + '</span>'
};

function Shark() {
  this.glyph = '^';
}
Shark.prototype.render = function() {
  return '<span style="color:white">' + this.glyph + '</span>'
};
Shark.prototype.act = function() {
  return {type:"move", direction:"e"};
};

function spriteFromGlyph(glyph) {
  switch (glyph) {
    case '^': return new Shark();
    case '>': return new Fish();
    case '|': return new Side();
    case 'V': return new Top();
    case '=': return new Bottom();
    case ' ':
    default:
      return null;
  }
}
function glyphFromSprite(sprite) {
  if (sprite == null) {
    return ' ';
  }
  else {
    return sprite.render();
  }
}

function Aquarium(plan) {
  var grid = new Grid(plan[0].length, plan.length);
  var line, x, y;

  for (y=0; y < plan.length; y++) {
    line = plan[y];
    for (x=0; x < line.length; x++) {
      grid.set(new Point(x, y), spriteFromGlyph(line.charAt(x)));
    }
  }

  this.grid = grid;
}
Aquarium.prototype.render = function() {
  var output = [];
  var eol = this.grid.width - 1;

  this.grid.each(function(pt, val) {
    output.push(glyphFromSprite(val));

    if (pt.x === eol) {
      output.push('\n')
    }
  });

  return output.join('');
};
Aquarium.prototype.findActors = function() {
  var actors = [];

  this.grid.each(function(pt, val) {
    if (val != null && val.act) {
      actors.push({"object": val, "point": pt});
    }
  });

  return actors;
};
Aquarium.prototype.defineSurroundings = function(center) {
  var result = {};
  var grid = this.grid;

  directions.each(function(name, direction) {
    var loc = center.add(direction);
    if (grid.isInside(loc)) {
      result[name] = glyphFromSprite(grid.val(loc));
    }
    else {
      result[name] = '|';
    }
  });

  return result;
};
Aquarium.prototype.processActor = function(actor) {
  var action = actor.object.act(this.defineSurroundings(actor.point));

  if (action.type == 'move' && directions.contains(action.direction)) {
    var to = actor.point.add(directions.get(action.direction));

    if (this.grid.isInside(to) && this.grid.val(to) == null) {
      this.grid.move(actor.point, to);
    }
  }
  else {
    throw new Error('Unsupported action: ' + action.type);
  }
};
Aquarium.prototype.step = function() {
//  forEachIn(this.findActors(), bind(this.processActor, this));
  var actors = this.findActors();
  var self = this;
  actors.forEach (function(item, i) {
    self.processActor(item);
  });
};


function buildPlan(w, h) {
  var plan = [];
  var a, i, j;

  a = [];
  for (i=0; i < w; i++) {
    a.push('V');
  }
  plan.push(a.join(''));

  for (j=0; j < h; j++) {
    a = [];
    a.push('|');
    for (i=1; i < (w -1); i++) {
      a.push(i%2 ? '+' : 'x');
    }
    a.push('|');
    plan.push(a.join(''));
  }

  a = [];
  for (i=0; i < w; i++) {
    a.push('=');
  }
  plan.push(a.join(''));

  return plan;
}

var directions = new Dictionary({
  'n': new Point(0, -1),
  'ne': new Point(1, -1),
  'e': new Point(1, 0),
  'se': new Point(1, 1),
  's': new Point(0, 1),
  'sw': new Point(-1, 1),
  'w': new Point(-1, 0),
  'nw': new Point(-1, -1)
});

var plan = buildPlan(90, 25);
var c;
c = plan[2].split('');
c[5] = '^';
plan[2] = c.join('');

/*
c = plan[22].split('');
c[30] = '>';
plan[22] = c.join('');
*/
var A = new Aquarium(plan);

var aquarium = document.getElementById('aquarium');
aquarium.innerHTML = A.render();

function tick() {
  A.step();
  aquarium.innerHTML = A.render();
}
setInterval(tick, 2000);

</script>
</body>
</html>